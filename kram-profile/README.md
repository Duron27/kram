kram-profile
==========

This profiler current wraps SwiftUI atop a WKWebView running the Perfetto TraceViewer.  Directories are searched, and files are open.  Supported files are added to a file list, and then can quickly view these in Perfetto.  The app is multidocument.

* .vmatrace - memory report generated by Kram scripts folder.
* .trace - performance timings in the form catapult trace json files
* .json - clang timing output generated using -ftime-trace

There are pre-built version of kram-profile for macOS 13.0 and higher.

References. See for more details:

* https://ui.perfetto.dev
* https://perfetto.dev/docs/visualization/deep-linking-to-perfetto-ui
* https://docs.google.com/document/d/1CvAClvFfyA5R-PhYUmn5OOQtYMH4h6I0nSsKchNAySU/preview#heading=h.yr4qxyxotyw

TODO:
* Fix document support, so can double click and have app open files
* Support binary Perfetto traces
* Fixup "Source" tags in clang json to use filename (no extension) from detail field
* Tie in with the excellent ClangBuildAnalyzer tool
* Scale specific traces to a single duration.  That way the next file comes in at that scale. 
* Preserve timeline duration across traces 

Perfetto
---------

This is a web-based profiling and flame-graph tool.  It's fast on desktop, and continues to evolve.  Only has second and timecode granularity which isn't enough.  For example, performance profiling for games is in milliseconds.  The team is mostly focused on Chrome profiling which apparently is in seconds.  But the visuals are nice, and it now has hover tips with size/name, and also has an Issues list that the devs are responsive to.  Flutter is using this profiler, and kram-profile does too.

Perfetto lives inside a sandbox due to the browser, so feeding files to Perfetto is it's weekness.  As a result kram-profile's file list is a nice complement, and can send the file data across via Javascript.  This is not unlike an Electron wrapper, but in much less memory.  

One limitation is that traces must be nested.  So timestamps cannot overlap.   Make sure to honor this, or traces will overlap verticall and become confused.  There is a C++ SDK to help with writing out traces, and that is a much more compact format than the json.  But more languages can write to the json format.  The Perfetto team is doing no further work on the json format.  And fields like "color" are unsupported, and Perfetto uses it's own coloration for blocks instead.  This coloration is nice and consistent and tied to name.

Memory profiling
---------

VMA can dump a json file, and that can be converted using scripts/GpuMemDumpPerfetto.py.  Then open this in kram-profile to see current memory fragmentation and layout across the various Vulkan heaps.  VMA can generate a png, but it's static.  Perfetto can allow one to zoom in and see the actual names of blocks and size.

Set the Pefetto timestamp to seconds, and then 1s = 1MB.  This allows reading the timings as megabytes.  A good timescale is 64s (64MB).

Performance profiling
---------

Have app write out time and duration events using the Catapult json format.  Then open these in kram-profile to optimize an application.   A good timescale is 0.1s for games.   Can then see where app performance is lost across threads and job systems.  It is harder to measure async wait gaps, since these are not nested properly.  Also good to instrument sleeps.  Not sure now to scope fibers, since these get swapped out.  There are events which aren't duration based, so use those.

Build profiling
---------

Clang supports -ftime-trace across all platforms.  Set that to dump the Perfetto trace files into the build directories alongside the .o files.  Then use kram-profile to open these folders.  Also see scripts/cba.sh for to run ClangBuildAnalyzer on these folders to identify where build timings are slow.  Then address with optimizing includes and using pch where possible.   A good timescale is 1s.  Files that take longer than this to build should be targeted.

Simd libraries, and especially files like STL with heavy template generation will often be at the top of the list.  PCH will reduce parsing time for templates, but not the instantiation.

Ideally run the traces, run CBA, reduce headers and identify pch candidates.  Then repeat, until overall timings go down.  Remember that PCH is per link, so one per DLL or app.  It also break isolation of headers in files, so may want a CI build not using it to catch unspecified headers.










